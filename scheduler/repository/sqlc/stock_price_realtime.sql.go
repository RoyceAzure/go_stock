// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: stock_price_realtime.sql

package repository

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkInsertSPRParams struct {
	Code         string         `json:"code"`
	StockName    string         `json:"stock_name"`
	TradeVolume  pgtype.Numeric `json:"trade_volume"`
	TradeValue   pgtype.Numeric `json:"trade_value"`
	OpeningPrice pgtype.Numeric `json:"opening_price"`
	HighestPrice pgtype.Numeric `json:"highest_price"`
	LowestPrice  pgtype.Numeric `json:"lowest_price"`
	ClosingPrice pgtype.Numeric `json:"closing_price"`
	Change       pgtype.Numeric `json:"change"`
	Transaction  pgtype.Numeric `json:"transaction"`
	TransTime    time.Time      `json:"trans_time"`
}

const createSPR = `-- name: CreateSPR :one
INSERT INTO "stock_price_realtime" (
    code,
    stock_name,
    trade_volume,
    trade_value,
    opening_price,
    highest_price,
    lowest_price,
    closing_price,
    change,
    transaction,
    trans_time
) VALUES(
    $1, $2, $3, $4,$5,$6,$7,$8,$9,$10, $11
) RETURNING code, stock_name, trade_volume, trade_value, opening_price, highest_price, lowest_price, closing_price, change, transaction, trans_time
`

type CreateSPRParams struct {
	Code         string         `json:"code"`
	StockName    string         `json:"stock_name"`
	TradeVolume  pgtype.Numeric `json:"trade_volume"`
	TradeValue   pgtype.Numeric `json:"trade_value"`
	OpeningPrice pgtype.Numeric `json:"opening_price"`
	HighestPrice pgtype.Numeric `json:"highest_price"`
	LowestPrice  pgtype.Numeric `json:"lowest_price"`
	ClosingPrice pgtype.Numeric `json:"closing_price"`
	Change       pgtype.Numeric `json:"change"`
	Transaction  pgtype.Numeric `json:"transaction"`
	TransTime    time.Time      `json:"trans_time"`
}

func (q *Queries) CreateSPR(ctx context.Context, arg CreateSPRParams) (StockPriceRealtime, error) {
	row := q.db.QueryRow(ctx, createSPR,
		arg.Code,
		arg.StockName,
		arg.TradeVolume,
		arg.TradeValue,
		arg.OpeningPrice,
		arg.HighestPrice,
		arg.LowestPrice,
		arg.ClosingPrice,
		arg.Change,
		arg.Transaction,
		arg.TransTime,
	)
	var i StockPriceRealtime
	err := row.Scan(
		&i.Code,
		&i.StockName,
		&i.TradeVolume,
		&i.TradeValue,
		&i.OpeningPrice,
		&i.HighestPrice,
		&i.LowestPrice,
		&i.ClosingPrice,
		&i.Change,
		&i.Transaction,
		&i.TransTime,
	)
	return i, err
}

const getSPRs = `-- name: GetSPRs :many
SELECT code, stock_name, trade_volume, trade_value, opening_price, highest_price, lowest_price, closing_price, change, transaction, trans_time FROM "stock_price_realtime"
WHERE ($1::varchar IS NULL OR code = $1)
    AND ($2::varchar IS NULL OR stock_name = $2)
    AND ($3::timestamptz IS NULL OR trans_time >= $3)
    AND ($4::timestamptz IS NULL OR trans_time <= $4)
ORDER BY code
LIMIT $6
OFFSET $5
`

type GetSPRsParams struct {
	Code           pgtype.Text        `json:"code"`
	StockName      pgtype.Text        `json:"stock_name"`
	TransTimeStart pgtype.Timestamptz `json:"trans_time_start"`
	TransTimeEnd   pgtype.Timestamptz `json:"trans_time_end"`
	Offsets        int32              `json:"offsets"`
	Limits         int32              `json:"limits"`
}

func (q *Queries) GetSPRs(ctx context.Context, arg GetSPRsParams) ([]StockPriceRealtime, error) {
	rows, err := q.db.Query(ctx, getSPRs,
		arg.Code,
		arg.StockName,
		arg.TransTimeStart,
		arg.TransTimeEnd,
		arg.Offsets,
		arg.Limits,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockPriceRealtime{}
	for rows.Next() {
		var i StockPriceRealtime
		if err := rows.Scan(
			&i.Code,
			&i.StockName,
			&i.TradeVolume,
			&i.TradeValue,
			&i.OpeningPrice,
			&i.HighestPrice,
			&i.LowestPrice,
			&i.ClosingPrice,
			&i.Change,
			&i.Transaction,
			&i.TransTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
