// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: stockTransation.sql

package db

import (
	"context"
	"time"
)

const createStockTransaction = `-- name: CreateStockTransaction :one
INSERT INTO stock_transaction(
    user_id,
    stock_id,
    transaction_type,
    transaction_date,
    transation_amt,
    transation_price_per_share,
    cr_user
) VALUES(
    $1, $2, $3, $4,$5,$6,$7
)   RETURNING "TransationId", user_id, stock_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user
`

type CreateStockTransactionParams struct {
	UserID                  int64     `json:"user_id"`
	StockID                 int64     `json:"stock_id"`
	TransactionType         string    `json:"transaction_type"`
	TransactionDate         time.Time `json:"transaction_date"`
	TransationAmt           int32     `json:"transation_amt"`
	TransationPricePerShare string    `json:"transation_price_per_share"`
	CrUser                  string    `json:"cr_user"`
}

func (q *Queries) CreateStockTransaction(ctx context.Context, arg CreateStockTransactionParams) (StockTransaction, error) {
	row := q.queryRow(ctx, q.createStockTransactionStmt, createStockTransaction,
		arg.UserID,
		arg.StockID,
		arg.TransactionType,
		arg.TransactionDate,
		arg.TransationAmt,
		arg.TransationPricePerShare,
		arg.CrUser,
	)
	var i StockTransaction
	err := row.Scan(
		&i.TransationId,
		&i.UserID,
		&i.StockID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.TransationAmt,
		&i.TransationPricePerShare,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const deleteStockTransaction = `-- name: DeleteStockTransaction :exec
DELETE FROM stock_transaction
WHERE "TransationId" = $1
`

func (q *Queries) DeleteStockTransaction(ctx context.Context, transationid int64) error {
	_, err := q.exec(ctx, q.deleteStockTransactionStmt, deleteStockTransaction, transationid)
	return err
}

const getStockTransaction = `-- name: GetStockTransaction :one
SELECT "TransationId", user_id, stock_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user FROM stock_transaction
WHERE "TransationId" = $1 LIMIT 1
`

func (q *Queries) GetStockTransaction(ctx context.Context, transationid int64) (StockTransaction, error) {
	row := q.queryRow(ctx, q.getStockTransactionStmt, getStockTransaction, transationid)
	var i StockTransaction
	err := row.Scan(
		&i.TransationId,
		&i.UserID,
		&i.StockID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.TransationAmt,
		&i.TransationPricePerShare,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const getStockTransactions = `-- name: GetStockTransactions :many
SELECT "TransationId", user_id, stock_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user FROM  stock_transaction
ORDER BY "TransationId"
LIMIT $1
OFFSET $2
`

type GetStockTransactionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetStockTransactions(ctx context.Context, arg GetStockTransactionsParams) ([]StockTransaction, error) {
	rows, err := q.query(ctx, q.getStockTransactionsStmt, getStockTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockTransaction{}
	for rows.Next() {
		var i StockTransaction
		if err := rows.Scan(
			&i.TransationId,
			&i.UserID,
			&i.StockID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockTransactionsByDate = `-- name: GetStockTransactionsByDate :many
SELECT "TransationId", user_id, stock_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user FROM stock_transaction
WHERE transaction_date = $1 
ORDER BY transaction_date
LIMIT $2
OFFSET $3
`

type GetStockTransactionsByDateParams struct {
	TransactionDate time.Time `json:"transaction_date"`
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
}

func (q *Queries) GetStockTransactionsByDate(ctx context.Context, arg GetStockTransactionsByDateParams) ([]StockTransaction, error) {
	rows, err := q.query(ctx, q.getStockTransactionsByDateStmt, getStockTransactionsByDate, arg.TransactionDate, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockTransaction{}
	for rows.Next() {
		var i StockTransaction
		if err := rows.Scan(
			&i.TransationId,
			&i.UserID,
			&i.StockID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockTransactionsByStockId = `-- name: GetStockTransactionsByStockId :many
SELECT "TransationId", user_id, stock_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user FROM stock_transaction
WHERE stock_id = $1
ORDER BY "TransationId"
LIMIT $2
OFFSET $3
`

type GetStockTransactionsByStockIdParams struct {
	StockID int64 `json:"stock_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) GetStockTransactionsByStockId(ctx context.Context, arg GetStockTransactionsByStockIdParams) ([]StockTransaction, error) {
	rows, err := q.query(ctx, q.getStockTransactionsByStockIdStmt, getStockTransactionsByStockId, arg.StockID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockTransaction{}
	for rows.Next() {
		var i StockTransaction
		if err := rows.Scan(
			&i.TransationId,
			&i.UserID,
			&i.StockID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockTransactionsByUserId = `-- name: GetStockTransactionsByUserId :many
SELECT "TransationId", user_id, stock_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user FROM stock_transaction
WHERE user_id = $1
ORDER BY "TransationId"
LIMIT $2
OFFSET $3
`

type GetStockTransactionsByUserIdParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetStockTransactionsByUserId(ctx context.Context, arg GetStockTransactionsByUserIdParams) ([]StockTransaction, error) {
	rows, err := q.query(ctx, q.getStockTransactionsByUserIdStmt, getStockTransactionsByUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockTransaction{}
	for rows.Next() {
		var i StockTransaction
		if err := rows.Scan(
			&i.TransationId,
			&i.UserID,
			&i.StockID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
