// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: fund.sql

package db

import (
	"context"
	"database/sql"
)

const createFund = `-- name: CreateFund :one
INSERT INTO fund(
    user_id,
    balance,
    currency_type,
    cr_user
) VALUES(
    $1, $2, $3, $4
)   RETURNING fund_id, user_id, balance, currency_type, cr_date, up_date, cr_user, up_user
`

type CreateFundParams struct {
	UserID       int64  `json:"user_id"`
	Balance      string `json:"balance"`
	CurrencyType string `json:"currency_type"`
	CrUser       string `json:"cr_user"`
}

func (q *Queries) CreateFund(ctx context.Context, arg CreateFundParams) (Fund, error) {
	row := q.db.QueryRowContext(ctx, createFund,
		arg.UserID,
		arg.Balance,
		arg.CurrencyType,
		arg.CrUser,
	)
	var i Fund
	err := row.Scan(
		&i.FundID,
		&i.UserID,
		&i.Balance,
		&i.CurrencyType,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const deleteFund = `-- name: DeleteFund :exec
DELETE FROM fund
WHERE fund_id = $1
`

func (q *Queries) DeleteFund(ctx context.Context, fundID int64) error {
	_, err := q.db.ExecContext(ctx, deleteFund, fundID)
	return err
}

const getFund = `-- name: GetFund :one
SELECT fund_id, user_id, balance, currency_type, cr_date, up_date, cr_user, up_user FROM fund
WHERE fund_id = $1 LIMIT 1
`

func (q *Queries) GetFund(ctx context.Context, fundID int64) (Fund, error) {
	row := q.db.QueryRowContext(ctx, getFund, fundID)
	var i Fund
	err := row.Scan(
		&i.FundID,
		&i.UserID,
		&i.Balance,
		&i.CurrencyType,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const getFundByUidandCurForUpdateNoK = `-- name: GetFundByUidandCurForUpdateNoK :one
SELECT fund_id, user_id, balance, currency_type, cr_date, up_date, cr_user, up_user FROM fund
WHERE user_id = $1
AND currency_type = $2
FOR NO KEY UPDATE
`

type GetFundByUidandCurForUpdateNoKParams struct {
	UserID       int64  `json:"user_id"`
	CurrencyType string `json:"currency_type"`
}

func (q *Queries) GetFundByUidandCurForUpdateNoK(ctx context.Context, arg GetFundByUidandCurForUpdateNoKParams) (Fund, error) {
	row := q.db.QueryRowContext(ctx, getFundByUidandCurForUpdateNoK, arg.UserID, arg.CurrencyType)
	var i Fund
	err := row.Scan(
		&i.FundID,
		&i.UserID,
		&i.Balance,
		&i.CurrencyType,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const getFundByUidandFid = `-- name: GetFundByUidandFid :one
SELECT fund_id, user_id, balance, currency_type, cr_date, up_date, cr_user, up_user FROM fund
WHERE user_id = $1
AND fund_id = $2
`

type GetFundByUidandFidParams struct {
	UserID int64 `json:"user_id"`
	FundID int64 `json:"fund_id"`
}

func (q *Queries) GetFundByUidandFid(ctx context.Context, arg GetFundByUidandFidParams) (Fund, error) {
	row := q.db.QueryRowContext(ctx, getFundByUidandFid, arg.UserID, arg.FundID)
	var i Fund
	err := row.Scan(
		&i.FundID,
		&i.UserID,
		&i.Balance,
		&i.CurrencyType,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const getFundByUidandFidForUpdateNoK = `-- name: GetFundByUidandFidForUpdateNoK :one
SELECT fund_id, user_id, balance, currency_type, cr_date, up_date, cr_user, up_user FROM fund
WHERE user_id = $1
AND fund_id = $2
FOR NO KEY UPDATE
`

type GetFundByUidandFidForUpdateNoKParams struct {
	UserID int64 `json:"user_id"`
	FundID int64 `json:"fund_id"`
}

func (q *Queries) GetFundByUidandFidForUpdateNoK(ctx context.Context, arg GetFundByUidandFidForUpdateNoKParams) (Fund, error) {
	row := q.db.QueryRowContext(ctx, getFundByUidandFidForUpdateNoK, arg.UserID, arg.FundID)
	var i Fund
	err := row.Scan(
		&i.FundID,
		&i.UserID,
		&i.Balance,
		&i.CurrencyType,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const getFundByUserId = `-- name: GetFundByUserId :many
SELECT fund_id, user_id, balance, currency_type, cr_date, up_date, cr_user, up_user FROM fund
WHERE user_id = $1
LIMIT $2
OFFSET $3
`

type GetFundByUserIdParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetFundByUserId(ctx context.Context, arg GetFundByUserIdParams) ([]Fund, error) {
	rows, err := q.db.QueryContext(ctx, getFundByUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Fund{}
	for rows.Next() {
		var i Fund
		if err := rows.Scan(
			&i.FundID,
			&i.UserID,
			&i.Balance,
			&i.CurrencyType,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFunds = `-- name: GetFunds :many
SELECT fund_id, user_id, balance, currency_type, cr_date, up_date, cr_user, up_user FROM  fund
ORDER BY fund_id
LIMIT $1
OFFSET $2
`

type GetFundsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetFunds(ctx context.Context, arg GetFundsParams) ([]Fund, error) {
	rows, err := q.db.QueryContext(ctx, getFunds, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Fund{}
	for rows.Next() {
		var i Fund
		if err := rows.Scan(
			&i.FundID,
			&i.UserID,
			&i.Balance,
			&i.CurrencyType,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFund = `-- name: UpdateFund :one
UPDATE fund
SET balance = $2,
up_date = $3,
up_user = $4
WHERE fund_id = $1
RETURNING fund_id, user_id, balance, currency_type, cr_date, up_date, cr_user, up_user
`

type UpdateFundParams struct {
	FundID  int64          `json:"fund_id"`
	Balance string         `json:"balance"`
	UpDate  sql.NullTime   `json:"up_date"`
	UpUser  sql.NullString `json:"up_user"`
}

func (q *Queries) UpdateFund(ctx context.Context, arg UpdateFundParams) (Fund, error) {
	row := q.db.QueryRowContext(ctx, updateFund,
		arg.FundID,
		arg.Balance,
		arg.UpDate,
		arg.UpUser,
	)
	var i Fund
	err := row.Scan(
		&i.FundID,
		&i.UserID,
		&i.Balance,
		&i.CurrencyType,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}
