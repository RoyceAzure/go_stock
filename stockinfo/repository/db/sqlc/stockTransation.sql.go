// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: stockTransation.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createStockTransaction = `-- name: CreateStockTransaction :one
INSERT INTO stock_transaction(
    user_id,
    stock_id,
    fund_id,
    transaction_type,
    transaction_date,
    transation_amt,
    transation_price_per_share,
    cr_user
) VALUES(
    $1, $2, $3, $4,$5,$6,$7,$8
)   RETURNING transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result
`

type CreateStockTransactionParams struct {
	UserID                  int64     `json:"user_id"`
	StockID                 int64     `json:"stock_id"`
	FundID                  int64     `json:"fund_id"`
	TransactionType         string    `json:"transaction_type"`
	TransactionDate         time.Time `json:"transaction_date"`
	TransationAmt           int32     `json:"transation_amt"`
	TransationPricePerShare string    `json:"transation_price_per_share"`
	CrUser                  string    `json:"cr_user"`
}

func (q *Queries) CreateStockTransaction(ctx context.Context, arg CreateStockTransactionParams) (StockTransaction, error) {
	row := q.db.QueryRowContext(ctx, createStockTransaction,
		arg.UserID,
		arg.StockID,
		arg.FundID,
		arg.TransactionType,
		arg.TransactionDate,
		arg.TransationAmt,
		arg.TransationPricePerShare,
		arg.CrUser,
	)
	var i StockTransaction
	err := row.Scan(
		&i.TransationID,
		&i.UserID,
		&i.StockID,
		&i.FundID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.TransationAmt,
		&i.TransationPricePerShare,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
		&i.Result,
	)
	return i, err
}

const deleteStockTransaction = `-- name: DeleteStockTransaction :exec
DELETE FROM stock_transaction
WHERE "transation_id" = $1
`

func (q *Queries) DeleteStockTransaction(ctx context.Context, transationID int64) error {
	_, err := q.db.ExecContext(ctx, deleteStockTransaction, transationID)
	return err
}

const getStockTransaction = `-- name: GetStockTransaction :one
SELECT transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result FROM stock_transaction
WHERE "transation_id" = $1 LIMIT 1
`

func (q *Queries) GetStockTransaction(ctx context.Context, transationID int64) (StockTransaction, error) {
	row := q.db.QueryRowContext(ctx, getStockTransaction, transationID)
	var i StockTransaction
	err := row.Scan(
		&i.TransationID,
		&i.UserID,
		&i.StockID,
		&i.FundID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.TransationAmt,
		&i.TransationPricePerShare,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
		&i.Result,
	)
	return i, err
}

const getStockTransactionsByDate = `-- name: GetStockTransactionsByDate :many
SELECT transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result FROM stock_transaction
WHERE transaction_date = $1 
ORDER BY transaction_date
LIMIT $2
OFFSET $3
`

type GetStockTransactionsByDateParams struct {
	TransactionDate time.Time `json:"transaction_date"`
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
}

func (q *Queries) GetStockTransactionsByDate(ctx context.Context, arg GetStockTransactionsByDateParams) ([]StockTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getStockTransactionsByDate, arg.TransactionDate, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockTransaction{}
	for rows.Next() {
		var i StockTransaction
		if err := rows.Scan(
			&i.TransationID,
			&i.UserID,
			&i.StockID,
			&i.FundID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockTransactionsByStockId = `-- name: GetStockTransactionsByStockId :many
SELECT transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result FROM stock_transaction
WHERE stock_id = $1
ORDER BY "transation_id"
LIMIT $2
OFFSET $3
`

type GetStockTransactionsByStockIdParams struct {
	StockID int64 `json:"stock_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) GetStockTransactionsByStockId(ctx context.Context, arg GetStockTransactionsByStockIdParams) ([]StockTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getStockTransactionsByStockId, arg.StockID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockTransaction{}
	for rows.Next() {
		var i StockTransaction
		if err := rows.Scan(
			&i.TransationID,
			&i.UserID,
			&i.StockID,
			&i.FundID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockTransactionsByUserId = `-- name: GetStockTransactionsByUserId :many
SELECT transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result FROM stock_transaction
WHERE user_id = $1
ORDER BY "transation_id"
LIMIT $2
OFFSET $3
`

type GetStockTransactionsByUserIdParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetStockTransactionsByUserId(ctx context.Context, arg GetStockTransactionsByUserIdParams) ([]StockTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getStockTransactionsByUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockTransaction{}
	for rows.Next() {
		var i StockTransaction
		if err := rows.Scan(
			&i.TransationID,
			&i.UserID,
			&i.StockID,
			&i.FundID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockTransactionsFilter = `-- name: GetStockTransactionsFilter :many
SELECT transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result FROM  stock_transaction
WHERE 
    user_id =  COALESCE(NULLIF($1,0), user_id)
    AND stock_id = COALESCE(NULLIF($2,0), stock_id)
    AND transaction_type = COALESCE($3, transaction_type)
ORDER BY "transation_id"
LIMIT $5
OFFSET $4
`

type GetStockTransactionsFilterParams struct {
	UserID          interface{}    `json:"user_id"`
	StockID         interface{}    `json:"stock_id"`
	TransactionType sql.NullString `json:"transaction_type"`
	Offsets         int32          `json:"offsets"`
	Limits          int32          `json:"limits"`
}

func (q *Queries) GetStockTransactionsFilter(ctx context.Context, arg GetStockTransactionsFilterParams) ([]StockTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getStockTransactionsFilter,
		arg.UserID,
		arg.StockID,
		arg.TransactionType,
		arg.Offsets,
		arg.Limits,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockTransaction{}
	for rows.Next() {
		var i StockTransaction
		if err := rows.Scan(
			&i.TransationID,
			&i.UserID,
			&i.StockID,
			&i.FundID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStockTransationResult = `-- name: UpdateStockTransationResult :one
Update stock_transaction
SET result = $1
WHERE transation_id = $2
RETURNING transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result
`

type UpdateStockTransationResultParams struct {
	Result       bool  `json:"result"`
	TransationID int64 `json:"transation_id"`
}

func (q *Queries) UpdateStockTransationResult(ctx context.Context, arg UpdateStockTransationResultParams) (StockTransaction, error) {
	row := q.db.QueryRowContext(ctx, updateStockTransationResult, arg.Result, arg.TransationID)
	var i StockTransaction
	err := row.Scan(
		&i.TransationID,
		&i.UserID,
		&i.StockID,
		&i.FundID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.TransationAmt,
		&i.TransationPricePerShare,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
		&i.Result,
	)
	return i, err
}
