// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: stockTransation.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createStockTransaction = `-- name: CreateStockTransaction :one
INSERT INTO stock_transaction(
    user_id,
    stock_id,
    fund_id,
    transaction_type,
    transaction_date,
    transation_amt,
    transation_price_per_share,
    cr_user,
    msg
) VALUES(
    $1, $2, $3, $4,$5,$6,$7,$8,$9
)   RETURNING transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result, msg
`

type CreateStockTransactionParams struct {
	UserID                  int64          `json:"user_id"`
	StockID                 int64          `json:"stock_id"`
	FundID                  int64          `json:"fund_id"`
	TransactionType         string         `json:"transaction_type"`
	TransactionDate         time.Time      `json:"transaction_date"`
	TransationAmt           int32          `json:"transation_amt"`
	TransationPricePerShare string         `json:"transation_price_per_share"`
	CrUser                  string         `json:"cr_user"`
	Msg                     sql.NullString `json:"msg"`
}

func (q *Queries) CreateStockTransaction(ctx context.Context, arg CreateStockTransactionParams) (StockTransaction, error) {
	row := q.db.QueryRowContext(ctx, createStockTransaction,
		arg.UserID,
		arg.StockID,
		arg.FundID,
		arg.TransactionType,
		arg.TransactionDate,
		arg.TransationAmt,
		arg.TransationPricePerShare,
		arg.CrUser,
		arg.Msg,
	)
	var i StockTransaction
	err := row.Scan(
		&i.TransationID,
		&i.UserID,
		&i.StockID,
		&i.FundID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.TransationAmt,
		&i.TransationPricePerShare,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
		&i.Result,
		&i.Msg,
	)
	return i, err
}

const deleteStockTransaction = `-- name: DeleteStockTransaction :exec
DELETE FROM stock_transaction
WHERE "transation_id" = $1
`

func (q *Queries) DeleteStockTransaction(ctx context.Context, transationID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteStockTransaction, transationID)
	return err
}

const getStockTransaction = `-- name: GetStockTransaction :one
SELECT transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result, msg FROM stock_transaction
WHERE "transation_id" = $1 LIMIT 1
`

func (q *Queries) GetStockTransaction(ctx context.Context, transationID uuid.UUID) (StockTransaction, error) {
	row := q.db.QueryRowContext(ctx, getStockTransaction, transationID)
	var i StockTransaction
	err := row.Scan(
		&i.TransationID,
		&i.UserID,
		&i.StockID,
		&i.FundID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.TransationAmt,
		&i.TransationPricePerShare,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
		&i.Result,
		&i.Msg,
	)
	return i, err
}

const getStockTransactionsByDate = `-- name: GetStockTransactionsByDate :many
SELECT transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result, msg FROM stock_transaction
WHERE transaction_date = $1 
ORDER BY transaction_date
LIMIT $2
OFFSET $3
`

type GetStockTransactionsByDateParams struct {
	TransactionDate time.Time `json:"transaction_date"`
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
}

func (q *Queries) GetStockTransactionsByDate(ctx context.Context, arg GetStockTransactionsByDateParams) ([]StockTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getStockTransactionsByDate, arg.TransactionDate, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockTransaction{}
	for rows.Next() {
		var i StockTransaction
		if err := rows.Scan(
			&i.TransationID,
			&i.UserID,
			&i.StockID,
			&i.FundID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
			&i.Result,
			&i.Msg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockTransactionsByStockId = `-- name: GetStockTransactionsByStockId :many
SELECT transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result, msg FROM stock_transaction
WHERE stock_id = $1
ORDER BY "transation_id"
LIMIT $2
OFFSET $3
`

type GetStockTransactionsByStockIdParams struct {
	StockID int64 `json:"stock_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) GetStockTransactionsByStockId(ctx context.Context, arg GetStockTransactionsByStockIdParams) ([]StockTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getStockTransactionsByStockId, arg.StockID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockTransaction{}
	for rows.Next() {
		var i StockTransaction
		if err := rows.Scan(
			&i.TransationID,
			&i.UserID,
			&i.StockID,
			&i.FundID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
			&i.Result,
			&i.Msg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockTransactionsByUserId = `-- name: GetStockTransactionsByUserId :many
SELECT transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result, msg FROM stock_transaction
WHERE user_id = $1
ORDER BY "transation_id"
LIMIT $2
OFFSET $3
`

type GetStockTransactionsByUserIdParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetStockTransactionsByUserId(ctx context.Context, arg GetStockTransactionsByUserIdParams) ([]StockTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getStockTransactionsByUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StockTransaction{}
	for rows.Next() {
		var i StockTransaction
		if err := rows.Scan(
			&i.TransationID,
			&i.UserID,
			&i.StockID,
			&i.FundID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
			&i.Result,
			&i.Msg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockTransactionsFilter = `-- name: GetStockTransactionsFilter :many
SELECT transation_id, user_id, stock_transaction.stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, stock_transaction.cr_date, stock_transaction.up_date, stock_transaction.cr_user, stock_transaction.up_user, result, msg, stock.stock_id, stock_code, stock_name, current_price, market_cap, stock.cr_date, stock.up_date, stock.cr_user, stock.up_user, stock.stock_code, stock.stock_name FROM  stock_transaction
LEFT JOIN stock
ON stock_transaction.stock_id = stock.stock_id
WHERE 
    stock_transaction.user_id =  COALESCE($1, stock_transaction.user_id)
    AND stock_transaction.stock_id = COALESCE($2, stock_transaction.stock_id)
    AND stock_transaction.transaction_type = COALESCE($3, stock_transaction.transaction_type)
ORDER BY stock_transaction.cr_date
LIMIT $5
OFFSET $4
`

type GetStockTransactionsFilterParams struct {
	UserID          sql.NullInt64  `json:"user_id"`
	StockID         sql.NullInt64  `json:"stock_id"`
	TransactionType sql.NullString `json:"transaction_type"`
	Offsets         int32          `json:"offsets"`
	Limits          int32          `json:"limits"`
}

type GetStockTransactionsFilterRow struct {
	TransationID            uuid.UUID        `json:"transation_id"`
	UserID                  int64            `json:"user_id"`
	StockID                 int64            `json:"stock_id"`
	FundID                  int64            `json:"fund_id"`
	TransactionType         string           `json:"transaction_type"`
	TransactionDate         time.Time        `json:"transaction_date"`
	TransationAmt           int32            `json:"transation_amt"`
	TransationPricePerShare string           `json:"transation_price_per_share"`
	CrDate                  time.Time        `json:"cr_date"`
	UpDate                  sql.NullTime     `json:"up_date"`
	CrUser                  string           `json:"cr_user"`
	UpUser                  sql.NullString   `json:"up_user"`
	Result                  TransationResult `json:"result"`
	Msg                     sql.NullString   `json:"msg"`
	StockID_2               sql.NullInt64    `json:"stock_id_2"`
	StockCode               sql.NullString   `json:"stock_code"`
	StockName               sql.NullString   `json:"stock_name"`
	CurrentPrice            sql.NullString   `json:"current_price"`
	MarketCap               sql.NullInt64    `json:"market_cap"`
	CrDate_2                sql.NullTime     `json:"cr_date_2"`
	UpDate_2                sql.NullTime     `json:"up_date_2"`
	CrUser_2                sql.NullString   `json:"cr_user_2"`
	UpUser_2                sql.NullString   `json:"up_user_2"`
	StockCode_2             sql.NullString   `json:"stock_code_2"`
	StockName_2             sql.NullString   `json:"stock_name_2"`
}

func (q *Queries) GetStockTransactionsFilter(ctx context.Context, arg GetStockTransactionsFilterParams) ([]GetStockTransactionsFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, getStockTransactionsFilter,
		arg.UserID,
		arg.StockID,
		arg.TransactionType,
		arg.Offsets,
		arg.Limits,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStockTransactionsFilterRow{}
	for rows.Next() {
		var i GetStockTransactionsFilterRow
		if err := rows.Scan(
			&i.TransationID,
			&i.UserID,
			&i.StockID,
			&i.FundID,
			&i.TransactionType,
			&i.TransactionDate,
			&i.TransationAmt,
			&i.TransationPricePerShare,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
			&i.Result,
			&i.Msg,
			&i.StockID_2,
			&i.StockCode,
			&i.StockName,
			&i.CurrentPrice,
			&i.MarketCap,
			&i.CrDate_2,
			&i.UpDate_2,
			&i.CrUser_2,
			&i.UpUser_2,
			&i.StockCode_2,
			&i.StockName_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStockTransationResult = `-- name: UpdateStockTransationResult :one
Update stock_transaction
SET result = $1,
    msg = COALESCE($2, msg)
WHERE transation_id = $3
RETURNING transation_id, user_id, stock_id, fund_id, transaction_type, transaction_date, transation_amt, transation_price_per_share, cr_date, up_date, cr_user, up_user, result, msg
`

type UpdateStockTransationResultParams struct {
	Result       TransationResult `json:"result"`
	Msg          sql.NullString   `json:"msg"`
	TransationID uuid.UUID        `json:"transation_id"`
}

func (q *Queries) UpdateStockTransationResult(ctx context.Context, arg UpdateStockTransationResultParams) (StockTransaction, error) {
	row := q.db.QueryRowContext(ctx, updateStockTransationResult, arg.Result, arg.Msg, arg.TransationID)
	var i StockTransaction
	err := row.Scan(
		&i.TransationID,
		&i.UserID,
		&i.StockID,
		&i.FundID,
		&i.TransactionType,
		&i.TransactionDate,
		&i.TransationAmt,
		&i.TransationPricePerShare,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
		&i.Result,
		&i.Msg,
	)
	return i, err
}
