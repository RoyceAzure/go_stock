// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: userStock.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createUserStock = `-- name: CreateUserStock :one
INSERT INTO user_stock(
    user_id,
    stock_id,
    quantity,
    purchase_price_per_share,
    purchased_date,
    cr_user
) VALUES(
    $1, $2, $3, $4, $5, $6
)   RETURNING user_stock_id, user_id, stock_id, quantity, purchase_price_per_share, purchased_date, cr_date, up_date, cr_user, up_user
`

type CreateUserStockParams struct {
	UserID                int64     `json:"user_id"`
	StockID               int64     `json:"stock_id"`
	Quantity              int32     `json:"quantity"`
	PurchasePricePerShare string    `json:"purchase_price_per_share"`
	PurchasedDate         time.Time `json:"purchased_date"`
	CrUser                string    `json:"cr_user"`
}

func (q *Queries) CreateUserStock(ctx context.Context, arg CreateUserStockParams) (UserStock, error) {
	row := q.db.QueryRowContext(ctx, createUserStock,
		arg.UserID,
		arg.StockID,
		arg.Quantity,
		arg.PurchasePricePerShare,
		arg.PurchasedDate,
		arg.CrUser,
	)
	var i UserStock
	err := row.Scan(
		&i.UserStockID,
		&i.UserID,
		&i.StockID,
		&i.Quantity,
		&i.PurchasePricePerShare,
		&i.PurchasedDate,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const deleteUserStock = `-- name: DeleteUserStock :exec
DELETE FROM user_stock
WHERE user_stock_id = $1
`

func (q *Queries) DeleteUserStock(ctx context.Context, userStockID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserStock, userStockID)
	return err
}

const getUserStock = `-- name: GetUserStock :one
SELECT user_stock_id, user_id, stock_id, quantity, purchase_price_per_share, purchased_date, cr_date, up_date, cr_user, up_user FROM user_stock
WHERE user_stock_id = $1 LIMIT 1
`

func (q *Queries) GetUserStock(ctx context.Context, userStockID int64) (UserStock, error) {
	row := q.db.QueryRowContext(ctx, getUserStock, userStockID)
	var i UserStock
	err := row.Scan(
		&i.UserStockID,
		&i.UserID,
		&i.StockID,
		&i.Quantity,
		&i.PurchasePricePerShare,
		&i.PurchasedDate,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const getUserStockByUidandSidForUpdateNoK = `-- name: GetUserStockByUidandSidForUpdateNoK :one
SELECT user_stock_id, user_id, stock_id, quantity, purchase_price_per_share, purchased_date, cr_date, up_date, cr_user, up_user FROM user_stock
WHERE user_id = $1
AND stock_id = $2
FOR NO KEY UPDATE
`

type GetUserStockByUidandSidForUpdateNoKParams struct {
	UserID  int64 `json:"user_id"`
	StockID int64 `json:"stock_id"`
}

func (q *Queries) GetUserStockByUidandSidForUpdateNoK(ctx context.Context, arg GetUserStockByUidandSidForUpdateNoKParams) (UserStock, error) {
	row := q.db.QueryRowContext(ctx, getUserStockByUidandSidForUpdateNoK, arg.UserID, arg.StockID)
	var i UserStock
	err := row.Scan(
		&i.UserStockID,
		&i.UserID,
		&i.StockID,
		&i.Quantity,
		&i.PurchasePricePerShare,
		&i.PurchasedDate,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const getUserStocks = `-- name: GetUserStocks :many
SELECT user_stock_id, user_id, stock_id, quantity, purchase_price_per_share, purchased_date, cr_date, up_date, cr_user, up_user FROM  user_stock
ORDER BY user_stock_id
LIMIT $1
OFFSET $2
`

type GetUserStocksParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetUserStocks(ctx context.Context, arg GetUserStocksParams) ([]UserStock, error) {
	rows, err := q.db.QueryContext(ctx, getUserStocks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserStock{}
	for rows.Next() {
		var i UserStock
		if err := rows.Scan(
			&i.UserStockID,
			&i.UserID,
			&i.StockID,
			&i.Quantity,
			&i.PurchasePricePerShare,
			&i.PurchasedDate,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStocksByPDate = `-- name: GetUserStocksByPDate :many
SELECT user_stock_id, user_id, stock_id, quantity, purchase_price_per_share, purchased_date, cr_date, up_date, cr_user, up_user FROM  user_stock
WHERE purchased_date = $1
ORDER BY user_stock_id
LIMIT $2
OFFSET $3
`

type GetUserStocksByPDateParams struct {
	PurchasedDate time.Time `json:"purchased_date"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
}

func (q *Queries) GetUserStocksByPDate(ctx context.Context, arg GetUserStocksByPDateParams) ([]UserStock, error) {
	rows, err := q.db.QueryContext(ctx, getUserStocksByPDate, arg.PurchasedDate, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserStock{}
	for rows.Next() {
		var i UserStock
		if err := rows.Scan(
			&i.UserStockID,
			&i.UserID,
			&i.StockID,
			&i.Quantity,
			&i.PurchasePricePerShare,
			&i.PurchasedDate,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStocksByStockId = `-- name: GetUserStocksByStockId :many
SELECT user_stock.user_stock_id, user_stock.user_id, user_stock.stock_id, user_stock.quantity, user_stock.purchase_price_per_share, user_stock.purchased_date, user_stock.cr_date, user_stock.up_date, user_stock.cr_user, user_stock.up_user, stock.stock_name FROM  user_stock
LEFT JOIN stock 
ON  user_stock.stock_id = stock.stock_id
WHERE user_stock.stock_id = $1
ORDER BY user_stock_id
LIMIT $2
OFFSET $3
`

type GetUserStocksByStockIdParams struct {
	StockID int64 `json:"stock_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type GetUserStocksByStockIdRow struct {
	UserStockID           int64          `json:"user_stock_id"`
	UserID                int64          `json:"user_id"`
	StockID               int64          `json:"stock_id"`
	Quantity              int32          `json:"quantity"`
	PurchasePricePerShare string         `json:"purchase_price_per_share"`
	PurchasedDate         time.Time      `json:"purchased_date"`
	CrDate                time.Time      `json:"cr_date"`
	UpDate                sql.NullTime   `json:"up_date"`
	CrUser                string         `json:"cr_user"`
	UpUser                sql.NullString `json:"up_user"`
	StockName             sql.NullString `json:"stock_name"`
}

func (q *Queries) GetUserStocksByStockId(ctx context.Context, arg GetUserStocksByStockIdParams) ([]GetUserStocksByStockIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserStocksByStockId, arg.StockID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserStocksByStockIdRow{}
	for rows.Next() {
		var i GetUserStocksByStockIdRow
		if err := rows.Scan(
			&i.UserStockID,
			&i.UserID,
			&i.StockID,
			&i.Quantity,
			&i.PurchasePricePerShare,
			&i.PurchasedDate,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
			&i.StockName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStocksByUserAStock = `-- name: GetUserStocksByUserAStock :many
SELECT user_stock_id, user_id, stock_id, quantity, purchase_price_per_share, purchased_date, cr_date, up_date, cr_user, up_user FROM  user_stock
WHERE purchased_date = $1
AND stock_id = $2
ORDER BY user_stock_id
LIMIT $3
OFFSET $4
`

type GetUserStocksByUserAStockParams struct {
	PurchasedDate time.Time `json:"purchased_date"`
	StockID       int64     `json:"stock_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
}

func (q *Queries) GetUserStocksByUserAStock(ctx context.Context, arg GetUserStocksByUserAStockParams) ([]UserStock, error) {
	rows, err := q.db.QueryContext(ctx, getUserStocksByUserAStock,
		arg.PurchasedDate,
		arg.StockID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserStock{}
	for rows.Next() {
		var i UserStock
		if err := rows.Scan(
			&i.UserStockID,
			&i.UserID,
			&i.StockID,
			&i.Quantity,
			&i.PurchasePricePerShare,
			&i.PurchasedDate,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStocksByUserId = `-- name: GetUserStocksByUserId :many
SELECT user_stock.user_stock_id, user_stock.user_id, user_stock.stock_id, user_stock.quantity, user_stock.purchase_price_per_share, user_stock.purchased_date, user_stock.cr_date, user_stock.up_date, user_stock.cr_user, user_stock.up_user, stock.stock_name FROM  user_stock
LEFT JOIN stock 
ON  user_stock.stock_id = stock.stock_id
WHERE user_stock.user_id = $1
ORDER BY user_stock_id
LIMIT $2
OFFSET $3
`

type GetUserStocksByUserIdParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetUserStocksByUserIdRow struct {
	UserStockID           int64          `json:"user_stock_id"`
	UserID                int64          `json:"user_id"`
	StockID               int64          `json:"stock_id"`
	Quantity              int32          `json:"quantity"`
	PurchasePricePerShare string         `json:"purchase_price_per_share"`
	PurchasedDate         time.Time      `json:"purchased_date"`
	CrDate                time.Time      `json:"cr_date"`
	UpDate                sql.NullTime   `json:"up_date"`
	CrUser                string         `json:"cr_user"`
	UpUser                sql.NullString `json:"up_user"`
	StockName             sql.NullString `json:"stock_name"`
}

func (q *Queries) GetUserStocksByUserId(ctx context.Context, arg GetUserStocksByUserIdParams) ([]GetUserStocksByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserStocksByUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserStocksByUserIdRow{}
	for rows.Next() {
		var i GetUserStocksByUserIdRow
		if err := rows.Scan(
			&i.UserStockID,
			&i.UserID,
			&i.StockID,
			&i.Quantity,
			&i.PurchasePricePerShare,
			&i.PurchasedDate,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
			&i.StockName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getserStockByUidandSid = `-- name: GetserStockByUidandSid :one
SELECT user_stock_id, user_id, stock_id, quantity, purchase_price_per_share, purchased_date, cr_date, up_date, cr_user, up_user FROM user_stock
WHERE user_id = $1
AND stock_id = $2
`

type GetserStockByUidandSidParams struct {
	UserID  int64 `json:"user_id"`
	StockID int64 `json:"stock_id"`
}

func (q *Queries) GetserStockByUidandSid(ctx context.Context, arg GetserStockByUidandSidParams) (UserStock, error) {
	row := q.db.QueryRowContext(ctx, getserStockByUidandSid, arg.UserID, arg.StockID)
	var i UserStock
	err := row.Scan(
		&i.UserStockID,
		&i.UserID,
		&i.StockID,
		&i.Quantity,
		&i.PurchasePricePerShare,
		&i.PurchasedDate,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const updateUserStock = `-- name: UpdateUserStock :one
UPDATE user_stock
SET quantity = $3,
purchase_price_per_share = $4,
purchased_date = $5,
up_date = $6,
up_user = $7
WHERE user_id = $1
AND stock_id = $2
RETURNING user_stock_id, user_id, stock_id, quantity, purchase_price_per_share, purchased_date, cr_date, up_date, cr_user, up_user
`

type UpdateUserStockParams struct {
	UserID                int64          `json:"user_id"`
	StockID               int64          `json:"stock_id"`
	Quantity              int32          `json:"quantity"`
	PurchasePricePerShare string         `json:"purchase_price_per_share"`
	PurchasedDate         time.Time      `json:"purchased_date"`
	UpDate                sql.NullTime   `json:"up_date"`
	UpUser                sql.NullString `json:"up_user"`
}

func (q *Queries) UpdateUserStock(ctx context.Context, arg UpdateUserStockParams) (UserStock, error) {
	row := q.db.QueryRowContext(ctx, updateUserStock,
		arg.UserID,
		arg.StockID,
		arg.Quantity,
		arg.PurchasePricePerShare,
		arg.PurchasedDate,
		arg.UpDate,
		arg.UpUser,
	)
	var i UserStock
	err := row.Scan(
		&i.UserStockID,
		&i.UserID,
		&i.StockID,
		&i.Quantity,
		&i.PurchasePricePerShare,
		&i.PurchasedDate,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}
